Here is the formatted content in a single Markdown code block, optimized for a professional GitHub repository.

```markdown
# ğŸš€ Day 01 â€“ Linux User Setup with Non-Interactive Shell

## ğŸ¯ Objective
Learn how to create Linux users with **non-interactive shells** to improve system security by preventing direct login access. This is a **common real-world DevOps and system administration practice** for service and application accounts.

---

## ğŸ‘¤ What is a Non-Interactive Shell?
A non-interactive shell is a shell that **does not allow users to log in via SSH or terminal**. It is used to enforce the **Principle of Least Privilege** for:
* Application users
* Service accounts
* Background processes
* Automation tools

---

## ğŸ” Common Non-Interactive Shells
| Shell Path | Purpose |
|:---|:---|
| `/sbin/nologin` | Displays a "This account is currently not available" message and denies login. |
| `/bin/false` | Immediately terminates the session without any message (returning a non-zero exit code). |

---

## ğŸ› ï¸ Hands-on Commands

### 1. Check Available Shells
Before assigning a shell, verify what is available on your system:
```bash
cat /etc/shells

```

### 2. Create a User with `/sbin/nologin`

```bash
sudo useradd -m -s /sbin/nologin appuser

```

* `-m` â†’ Creates the home directory.
* `-s` â†’ Assigns the specific login shell.

### 3. Create a User with `/bin/false`

```bash
sudo useradd -m -s /bin/false serviceuser

```

### 4. Verify User Shell

```bash
grep "appuser" /etc/passwd

```

**Example Output:** `appuser:x:1002:1002::/home/appuser:/sbin/nologin`

### 5. Attempt Login (Expected to Fail)

Testing the restriction via SSH or switching users:

```bash
ssh appuser@localhost
# OR
su - appuser

```

**Expected Result:** `This account is currently not available.`

### 6. Modify an Existing User

To harden an existing account by changing its shell:

```bash
sudo usermod -s /sbin/nologin existinguser

```

### 7. Account Hardening (Locking)

Optional step to ensure the password cannot be used:

```bash
sudo passwd -l appuser      # Lock the password
sudo passwd -S appuser      # Check login status (L = Locked)

```

---

## ğŸ“Œ Real-World Use Cases

* **Database service accounts** (e.g., mysql, postgres)
* **Application runtime users** (e.g., nodejs, python)
* **CI/CD agents** (e.g., Jenkins, GitLab runner)
* **Monitoring services** (e.g., Prometheus, Grafana)

---

## ğŸ§  Key Learnings

* **Security First:** Not every user account requires a human to log in.
* **Clear Messaging:** `/sbin/nologin` is preferred over `/bin/false` because it provides feedback to the user/admin.
* **Attack Surface Reduction:** Disabling shell access prevents attackers from gaining a command prompt even if they compromise a service's credentials.

```

Would you like me to create a similar guide for **Managing Sudo Privileges and Sudoers Files** for Day 02?

```
